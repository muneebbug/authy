import 'package:hive/hive.dart';
import 'package:authy/core/utils/secure_storage_service.dart';
import 'package:authy/core/utils/totp_service.dart';
import 'package:authy/data/models/account_model.dart';
import 'package:authy/domain/entities/account.dart';
import 'package:authy/domain/repositories/account_repository.dart';

/// Implementation of the account repository
class AccountRepositoryImpl implements AccountRepository {
  static const String _boxName = 'accounts';
  final Box<AccountModel> _accountBox;

  AccountRepositoryImpl(this._accountBox);

  /// Factory constructor to initialize Hive and open the account box
  static Future<AccountRepositoryImpl> create() async {
    try {
      print("Initializing AccountRepositoryImpl...");

      // Register adapter for AccountModel
      if (!Hive.isAdapterRegistered(0)) {
        print("Registering AccountModelAdapter");
        Hive.registerAdapter(AccountModelAdapter());
      }

      // Register adapter for Algorithm enum
      if (!Hive.isAdapterRegistered(2)) {
        print("Registering Algorithm enum adapter");
        // The adapter should be generated by build_runner
        Hive.registerAdapter(AlgorithmAdapter());
      }

      print("Opening Hive box: $_boxName");
      final box = await Hive.openBox<AccountModel>(_boxName);
      print("Hive box opened successfully, count: ${box.length}");
      return AccountRepositoryImpl(box);
    } catch (e, stack) {
      print("Error initializing AccountRepositoryImpl: $e");
      print("Stack trace: $stack");
      rethrow;
    }
  }

  @override
  Future<List<Account>> getAllAccounts() async {
    try {
      print("Getting all accounts, count: ${_accountBox.length}");
      final accounts = _accountBox.values.toList();
      final List<Account> decryptedAccounts = [];

      for (final account in accounts) {
        try {
          final decryptedSecretKey = SecureStorageService.decrypt(
            account.secretKey,
          );
          final decryptedAccount = account.copyWith(
            secretKey: decryptedSecretKey,
          );
          decryptedAccounts.add(decryptedAccount);
        } catch (e) {
          print("Error decrypting account: $e");
          // Skip accounts with invalid encryption
          continue;
        }
      }

      print("Returned ${decryptedAccounts.length} decrypted accounts");
      return decryptedAccounts;
    } catch (e, stack) {
      print("Error getting all accounts: $e");
      print("Stack trace: $stack");
      rethrow;
    }
  }

  @override
  Future<Account?> getAccountById(String id) async {
    final account = _accountBox.get(id);
    if (account == null) {
      return null;
    }

    try {
      final decryptedSecretKey = SecureStorageService.decrypt(
        account.secretKey,
      );
      return account.copyWith(secretKey: decryptedSecretKey);
    } catch (e) {
      // Return null if decryption fails
      return null;
    }
  }

  @override
  Future<void> addAccount(Account account) async {
    try {
      print("Adding account: ${account.issuer}");
      final encryptedSecretKey = SecureStorageService.encrypt(
        account.secretKey,
      );
      print("Secret key encrypted");
      final encryptedAccount = AccountModel.fromEntity(
        account.copyWith(secretKey: encryptedSecretKey),
      );
      print("Account model created");

      await _accountBox.put(account.id, encryptedAccount);
      print("Account saved to box with ID: ${account.id}");
    } catch (e, stack) {
      print("Error adding account: $e");
      print("Stack trace: $stack");
      rethrow;
    }
  }

  @override
  Future<void> updateAccount(Account account) async {
    final existingAccount = await getAccountById(account.id);
    if (existingAccount == null) {
      throw Exception('Account not found');
    }

    // If secret key has changed, encrypt it
    final String encryptedSecretKey;
    if (account.secretKey != existingAccount.secretKey) {
      encryptedSecretKey = SecureStorageService.encrypt(account.secretKey);
    } else {
      // Get the original encrypted key if it hasn't changed
      final originalAccount = _accountBox.get(account.id);
      encryptedSecretKey = originalAccount!.secretKey;
    }

    final encryptedAccount = AccountModel.fromEntity(
      account.copyWith(secretKey: encryptedSecretKey),
    );

    await _accountBox.put(account.id, encryptedAccount);
  }

  @override
  Future<void> deleteAccount(String id) async {
    await _accountBox.delete(id);
  }

  @override
  Future<String> generateCode(Account account) async {
    // Update last used timestamp
    final updatedAccount = account.copyWith(lastUsedAt: DateTime.now());
    await updateAccount(updatedAccount);

    // Generate the TOTP code
    return TOTPService.generateCode(account);
  }

  @override
  int getRemainingSeconds(Account account) {
    return TOTPService.getRemainingSeconds(account);
  }
}
