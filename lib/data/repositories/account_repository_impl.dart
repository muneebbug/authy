import 'package:hive/hive.dart';
import 'package:sentinel/core/utils/secure_storage_service.dart';
import 'package:sentinel/core/utils/totp_service.dart';
import 'package:sentinel/data/models/account_model.dart';
import 'package:sentinel/domain/entities/account.dart';
import 'package:sentinel/domain/repositories/account_repository.dart';
import 'package:sentinel/core/utils/logger_util.dart';

/// Implementation of the account repository
class AccountRepositoryImpl implements AccountRepository {
  static const String _boxName = 'accounts';
  final Box<AccountModel> _accountBox;

  AccountRepositoryImpl(this._accountBox);

  /// Factory constructor to initialize Hive and open the account box
  static Future<AccountRepositoryImpl> create() async {
    try {
      LoggerUtil.info("Initializing AccountRepositoryImpl...");

      // Register adapter for AccountModel
      if (!Hive.isAdapterRegistered(0)) {
        LoggerUtil.debug("Registering AccountModelAdapter");
        Hive.registerAdapter(AccountModelAdapter());
      }

      // Register adapter for Algorithm enum
      if (!Hive.isAdapterRegistered(2)) {
        LoggerUtil.debug("Registering Algorithm enum adapter");
        // The adapter should be generated by build_runner
        Hive.registerAdapter(AlgorithmAdapter());
      }

      LoggerUtil.debug("Opening Hive box: $_boxName");
      final box = await Hive.openBox<AccountModel>(_boxName);
      LoggerUtil.debug("Hive box opened successfully, count: ${box.length}");
      return AccountRepositoryImpl(box);
    } catch (e, stack) {
      LoggerUtil.error("Error initializing AccountRepositoryImpl", e, stack);
      rethrow;
    }
  }

  @override
  Future<List<Account>> getAllAccounts() async {
    try {
      LoggerUtil.debug("Getting all accounts, count: ${_accountBox.length}");
      final accounts = _accountBox.values.toList();
      final List<Account> decryptedAccounts = [];

      for (final account in accounts) {
        try {
          final decryptedSecretKey = SecureStorageService.decrypt(
            account.secretKey,
          );
          final decryptedAccount = account.copyWith(
            secretKey: decryptedSecretKey,
          );
          decryptedAccounts.add(decryptedAccount);
        } catch (e) {
          LoggerUtil.error("Error decrypting account", e);
          // Skip accounts with invalid encryption
          continue;
        }
      }

      LoggerUtil.debug(
        "Returned ${decryptedAccounts.length} decrypted accounts",
      );
      return decryptedAccounts;
    } catch (e, stack) {
      LoggerUtil.error("Error getting all accounts", e, stack);
      rethrow;
    }
  }

  @override
  Future<Account?> getAccountById(String id) async {
    final account = _accountBox.get(id);
    if (account == null) {
      return null;
    }

    try {
      final decryptedSecretKey = SecureStorageService.decrypt(
        account.secretKey,
      );
      return account.copyWith(secretKey: decryptedSecretKey);
    } catch (e) {
      // Return null if decryption fails
      return null;
    }
  }

  @override
  Future<void> addAccount(Account account) async {
    try {
      LoggerUtil.info("Adding account: ${account.issuer}");
      final encryptedSecretKey = SecureStorageService.encrypt(
        account.secretKey,
      );
      LoggerUtil.info("Secret key encrypted");
      final encryptedAccount = AccountModel.fromEntity(
        account.copyWith(secretKey: encryptedSecretKey),
      );
      LoggerUtil.info("Account model created");

      await _accountBox.put(account.id, encryptedAccount);
      LoggerUtil.info("Account saved to box with ID: ${account.id}");
    } catch (e, stack) {
      LoggerUtil.error("Error adding account", e, stack);
      rethrow;
    }
  }

  @override
  Future<void> updateAccount(Account account) async {
    final existingAccount = await getAccountById(account.id);
    if (existingAccount == null) {
      throw Exception('Account not found');
    }

    // If secret key has changed, encrypt it
    final String encryptedSecretKey;
    if (account.secretKey != existingAccount.secretKey) {
      encryptedSecretKey = SecureStorageService.encrypt(account.secretKey);
    } else {
      // Get the original encrypted key if it hasn't changed
      final originalAccount = _accountBox.get(account.id);
      encryptedSecretKey = originalAccount!.secretKey;
    }

    final encryptedAccount = AccountModel.fromEntity(
      account.copyWith(secretKey: encryptedSecretKey),
    );

    await _accountBox.put(account.id, encryptedAccount);
  }

  @override
  Future<void> deleteAccount(String id) async {
    await _accountBox.delete(id);
  }

  @override
  Future<String> generateCode(Account account) async {
    // Update last used timestamp
    final updatedAccount = account.copyWith(lastUsedAt: DateTime.now());
    await updateAccount(updatedAccount);

    // Generate the TOTP code
    return TOTPService.generateCode(account);
  }

  @override
  int getRemainingSeconds(Account account) {
    return TOTPService.getRemainingSeconds(account);
  }
}
